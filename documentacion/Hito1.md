# Escape del Laberinto: Hito 1 üöÄ

---

## Tabla de contenidos

- [Escape del Laberinto: Hito 1 üöÄ](#escape-del-laberinto-hito-1-)
  - [Tabla de contenidos](#tabla-de-contenidos)
  - [GDD b√°sico üìù](#gdd-b√°sico-)
    - [¬øEn que consiste nuestro juego?](#en-que-consiste-nuestro-juego)
      - [Componentes y mec√°nicas principales](#componentes-y-mec√°nicas-principales)
  - [Elecci√≥n de estrategia de gesti√≥n de ramas üåø](#elecci√≥n-de-estrategia-de-gesti√≥n-de-ramas-)
    - [Flujo de trabajo](#flujo-de-trabajo)
    - [Ejemplo de Pull Request](#ejemplo-de-pull-request)
    - [Ejemplo de rama feature](#ejemplo-de-rama-feature)
  - [Sistema de bugtracking elegido üêõ](#sistema-de-bugtracking-elegido-)
    - [Ejemplo de Issue](#ejemplo-de-issue)
  - [Conclusiones ‚úÖ](#conclusiones-)
  - [Autores ‚úçÔ∏è](#autores-Ô∏è)

---

## GDD b√°sico üìù

### ¬øEn que consiste nuestro juego?

**Escape del Laberinto** es un videojuego de exploraci√≥n y supervivencia en 2D desarrollado en C++ con Raylib, en el que el jugador deber√° encontrar la llave y escapar del laberinto evitando enemigos, trampas y mecanismos bloqueantes.

El objetivo es alcanzar la salida (X) con la llave (K) en su mochila, gestionando el movimiento, las colisiones y las vidas limitadas mientras se resuelven obst√°culos din√°micos.

#### Estructura del juego
- Pantalla de inicio: men√∫ simple con opci√≥n de empezar partida.
- Pantalla principal: se muestra el mapa jugable, el jugador, los enemigos y el HUD inferior.
- Pantalla de Game Over: aparece cuando el jugador pierde todas sus vidas o logra escapar.
- Todo gestionado mediante una m√°quina de estados (StateMachine) con transiciones limpias entre StartGameState, MainGameState y GameOverState.

#### Componentes y mec√°nicas principales
- Jugador (Player):
  - Movimiento fluido en las cuatro direcciones (WASD o flechas, sin diagonales).
  - Vidas: empieza con 5, es decir, puede recibir hasta 5 golpes de obst√°culos/enemigos; pierde una al chocar con un enemigo o pinchos activos.  
  - Colisi√≥n con el mapa: no atraviesa paredes ni mecanismos cerrados.    
  - Mochila: muestra los objetos recogidos para indicar los objetos que lleva en ese momento o recoge por el camino.  
    - Actualmente puede portar una llave (K) necesaria para abrir la salida.
  - Invulnerabilidad temporal: tras recibir da√±o, tiene unos instantes de inmunidad.  
  - Interacci√≥n: puede activar mecanismos (botones/palancas) que modifican el entorno.
  - Condiciones:
    - Victoria: llega a la salida (X) teniendo la llave.
    - Derrota: pierde todas las vidas o termina el tiempo.
- Mecanismos (Mechanism):
  - Son bloqueos o puertas que el jugador no puede atravesar hasta que se activa su trigger (bot√≥n, interruptor o palanca).  
  - Cada mecanismo tiene:  
    - Tipo (puerta, puente, trampa, etc.).  
    - Estado (activo/inactivo).  
  - Vinculaci√≥n entre activador y objetivo.  
    - Su estado puede cambiar din√°micamente durante la partida, alterando el camino disponible.
- Enemigos (Enemy):
  - Patrullan el laberinto de forma semialeatoria (movimiento aut√≥nomo con direcci√≥n variable).
  - Al colisionar con el jugador, le quitan una vida.
  - Son entidades independientes que se actualizan en cada frame.
  - Su presencia aumenta la dificultad del recorrido y obliga al jugador a planificar rutas seguras.
- Pinchos (spikes):
  - Los pinchos cuando se muestran pueden quitarle vidas al jugador al colisionar con estos. 
  - Los pinchos se pueden atravesar por el jugador si est√°n ocultos.

## Elecci√≥n de estrategia de gesti√≥n de ramas üåø

Para la gesti√≥n de nuestro repositorio del proyecto ***Escape del Laberinto***, hemos optado por la estrategia **GitHub Flow**. Esta elecci√≥n se basa en la naturaleza √°gil y colaborativa del desarrollo de nuestro juego, que requiere iteraciones frecuentes sobre el c√≥digo y una integraci√≥n continua de las funcionalidades desarrolladas por cada miembro del equipo.

**GitHub Flow** se adapta perfectamente a nuestro proyecto porque:

- Permite trabajar con **ramas cortas y espec√≠ficas**, dedicadas a nuevas caracter√≠sticas o correcciones puntuales. Cada desarrollador puede crear su propia rama a partir de `main` para implementar funcionalidades como la l√≥gica de movimiento, la gesti√≥n de enemigos o el sistema de estados del juego.
- Facilita la **revisi√≥n de c√≥digo mediante Pull Requests**, asegurando que cualquier cambio que se integre en `main` sea previamente revisado por al menos otro miembro del equipo. Esto mejora la calidad del c√≥digo y minimiza errores antes de la integraci√≥n.
- Se centra en **despliegues frecuentes y seguros**, lo que nos permite mantener `main` siempre en un estado jugable y funcional, incluso durante el desarrollo activo de nuevas mec√°nicas o pantallas.
- Mantiene el flujo simple y flexible, evitando la complejidad que podr√≠a introducir **GitFlow**, m√°s orientado a proyectos con ciclos de release definidos y m√∫ltiples ramas intermedias.

### Flujo de trabajo

1. Crear una rama `feature/nombre-feature` a partir de `main`.
2. Implementar la funcionalidad o correcci√≥n correspondiente.
3. Abrir un **Pull Request** hacia `main` para revisi√≥n de cambios.
4. Una vez aprobado, fusionar la rama y eliminarla local y remotamente.
5. Mantener `main` siempre en estado estable y jugable, permitiendo generar releases f√°cilmente.

### Ejemplo de Pull Request

| Pull Request | Estado | Etiquetas | Asignado a |
|--------------|--------|-----------|------------|
| `PR #5: Implementar movimiento jugador` | ‚úÖ Aprobado | `feature`, `ready-for-merge` | Fernando |
| `PR #7: Correcci√≥n colisiones` | üõ† En revisi√≥n | `bug`, `needs-review` | Alex |

### Ejemplo de rama feature

```text
feature/1-mapa-estatico
feature/5-crear-estado-GameOver
hotfix/8-collision-bug
```

**Esquema visual de GitHub Flow:**

```mermaid
flowchart TD
    subgraph IssueTracking[Issue Tracking]
        A[üìù Issue / Bug / Task]
    end
    subgraph DevFlow[Desarrollo]
        B[üåø Crear rama feature]
        C[üíª Desarrollar funcionalidad]
        D[üîç Pull Request abierto]
        E{üìù Revisi√≥n de c√≥digo}
        F[üîÄ Merge en rama main]
    end
    G[üè∑ Release / Tag]

    A --> B
    B --> C
    C --> D
    D --> E
    E -->|‚úÖ Aprobado| F
    E -->|üõ† Comentarios / Mejoras| C
    F --> G
```

Este diagrama representa c√≥mo un *issue* inicia el flujo de trabajo, pasando por la creaci√≥n de una rama espec√≠fica, desarrollo, revisi√≥n mediante *Pull Request* y finalmente la integraci√≥n en `main` con la generaci√≥n de una release estable.

Esta metodolog√≠a asegura que todos los desarrolladores en el equipo podamos trabajar de manera independiente, mientras `main` refleja el estado consolidado y funcional del juego.

---

## Sistema de bugtracking elegido üêõ

Para el seguimiento de incidencias y control de errores, nos hemos decantado por **GitHub Issues** como sistema de ***bugtracking***. Esta decisi√≥n se fundamenta en varias razones:

- **Integraci√≥n directa con GitHub**, nuestro repositorio central, lo que permite asociar *issues* directamente a commits y *Pull Requests*.
- **Simplicidad y claridad**: cada *bug*, tarea o mejora se puede documentar en un issue individual con t√≠tulo, descripci√≥n, etiquetas, asignaci√≥n de responsables y estado.
- **Colaboraci√≥n eficiente**: todos los miembros del equipo pueden comentar, actualizar el estado y cerrar issues de manera transparente, facilitando la comunicaci√≥n y seguimiento de tareas.
- **Vinculaci√≥n con milestones y releases**: podemos asociar *issues* a cada hito o versi√≥n del juego, permitiendo un control claro de qu√© tareas se han completado y cu√°les est√°n pendientes.

### Ejemplo de Issue

| Issue | Estado | Etiquetas | Asignado a |
|-------|--------|-----------|------------|
| `#12: Jugador atraviesa paredes` | ‚ö† Abierto | `bug`, `high-priority` | Esther |
| `#15: A√±adir sonidos al recoger power-ups` | ‚úÖ Cerrado | `feature`, `audio` | Hugo |
| `#18: Mejora IA enemigos` | ‚è≥ En progreso | `enhancement`, `AI` | Alex |
| `#21: Pantalla de Game Over falta bot√≥n reiniciar` | ‚ö† Abierto | `bug`, `UI` | Fernando |

Al utilizar **GitHub Issues**, conseguimos centralizar la gesti√≥n de bugs y tareas en la misma plataforma que usamos para el c√≥digo, simplificando la administraci√≥n del proyecto y asegurando trazabilidad completa de los cambios implementados.

---

## Conclusiones ‚úÖ

Gracias a GitHub Flow y GitHub Issues, nuestro equipo mantiene main siempre estable y funcional, facilita la colaboraci√≥n, asegura la revisi√≥n de cada cambio y permite asociar tareas y bugs directamente a commits y Pull Requests. Esto garantiza un desarrollo m√°s ordenado, controlado y transparente, ideal para proyectos colaborativos como Escape del Laberinto.

---

## Autores ‚úçÔ∏è

- **Esther Peral Soler**
- **Hugo Redondo Vald√©s**
- **Alejandro Montoya Aracil**
- **Juan Fernando Ganim Iborra**
