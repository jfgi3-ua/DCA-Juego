# Escape del Laberinto: Hito 1 üöÄ

---

## Tabla de contenidos

1. [GDD b√°sico](#gdd-b√°sico)
2. [Elecci√≥n de estrategia de gesti√≥n de ramas](#elecci√≥n-de-estrategia-de-gesti√≥n-de-ramas)
3. [Sistema de bugtracking elegido](#sistema-de-bugtracking-elegido)
4. [Conclusiones](#conclusiones)

---

## GDD b√°sico üìù

> **Nota:** Este cap√≠tulo se completar√° una vez finalicemos el desarrollo de la primera versi√≥n jugable del juego. Aqu√≠ se documentar√°n las mec√°nicas principales, pantallas, enemigos, power-ups y dem√°s elementos relevantes del proyecto.

---

## Elecci√≥n de estrategia de gesti√≥n de ramas üåø

Para la gesti√≥n de nuestro repositorio del proyecto ***Escape del Laberinto***, hemos optado por la estrategia **GitHub Flow**. Esta elecci√≥n se basa en la naturaleza √°gil y colaborativa del desarrollo de nuestro juego, que requiere iteraciones frecuentes sobre el c√≥digo y una integraci√≥n continua de las funcionalidades desarrolladas por cada miembro del equipo.

**GitHub Flow** se adapta perfectamente a nuestro proyecto porque:

- Permite trabajar con **ramas cortas y espec√≠ficas**, dedicadas a nuevas caracter√≠sticas o correcciones puntuales. Cada desarrollador puede crear su propia rama a partir de `main` para implementar funcionalidades como la l√≥gica de movimiento, la gesti√≥n de enemigos o el sistema de estados del juego.
- Facilita la **revisi√≥n de c√≥digo mediante Pull Requests**, asegurando que cualquier cambio que se integre en `main` sea previamente revisado por al menos otro miembro del equipo. Esto mejora la calidad del c√≥digo y minimiza errores antes de la integraci√≥n.
- Se centra en **despliegues frecuentes y seguros**, lo que nos permite mantener `main` siempre en un estado jugable y funcional, incluso durante el desarrollo activo de nuevas mec√°nicas o pantallas.
- Mantiene el flujo simple y flexible, evitando la complejidad que podr√≠a introducir **GitFlow**, m√°s orientado a proyectos con ciclos de release definidos y m√∫ltiples ramas intermedias.

### Flujo de trabajo

1. Crear una rama `feature/nombre-feature` a partir de `main`.
2. Implementar la funcionalidad o correcci√≥n correspondiente.
3. Abrir un **Pull Request** hacia `main` para revisi√≥n de cambios.
4. Una vez aprobado, fusionar la rama y eliminarla local y remotamente.
5. Mantener `main` siempre en estado estable y jugable, permitiendo generar releases f√°cilmente.

### Ejemplo de Pull Request

| Pull Request | Estado | Etiquetas | Asignado a |
|--------------|--------|-----------|------------|
| `PR #5: Implementar movimiento jugador` | ‚úÖ Aprobado | `feature`, `ready-for-merge` | Fernando |
| `PR #7: Correcci√≥n colisiones` | üõ† En revisi√≥n | `bug`, `needs-review` | Alex |

### Ejemplo de rama feature

```text
feature/1-mapa-estatico
feature/5-crear-estado-GameOver
hotfix/8-collision-bug
```

**Esquema visual de GitHub Flow:**

```mermaid
flowchart TD
    subgraph IssueTracking[Issue Tracking]
        A[üìù Issue / Bug / Task]
    end
    subgraph DevFlow[Desarrollo]
        B[üåø Crear rama feature]
        C[üíª Desarrollar funcionalidad]
        D[üîç Pull Request abierto]
        E{üìù Revisi√≥n de c√≥digo}
        F[üîÄ Merge en rama main]
    end
    G[üè∑ Release / Tag]

    A --> B
    B --> C
    C --> D
    D --> E
    E -->|‚úÖ Aprobado| F
    E -->|üõ† Comentarios / Mejoras| C
    F --> G
```

Este diagrama representa c√≥mo un *issue* inicia el flujo de trabajo, pasando por la creaci√≥n de una rama espec√≠fica, desarrollo, revisi√≥n mediante *Pull Request* y finalmente la integraci√≥n en `main` con la generaci√≥n de una release estable.

Esta metodolog√≠a asegura que todos los desarrolladores en el equipo podamos trabajar de manera independiente, mientras `main` refleja el estado consolidado y funcional del juego.

---

## Sistema de bugtracking elegido üêõ

Para el seguimiento de incidencias y control de errores, nos hemos decantado por **GitHub Issues** como sistema de ***bugtracking***. Esta decisi√≥n se fundamenta en varias razones:

- **Integraci√≥n directa con GitHub**, nuestro repositorio central, lo que permite asociar *issues* directamente a commits y *Pull Requests*.
- **Simplicidad y claridad**: cada *bug*, tarea o mejora se puede documentar en un issue individual con t√≠tulo, descripci√≥n, etiquetas, asignaci√≥n de responsables y estado.
- **Colaboraci√≥n eficiente**: todos los miembros del equipo pueden comentar, actualizar el estado y cerrar issues de manera transparente, facilitando la comunicaci√≥n y seguimiento de tareas.
- **Vinculaci√≥n con milestones y releases**: podemos asociar *issues* a cada hito o versi√≥n del juego, permitiendo un control claro de qu√© tareas se han completado y cu√°les est√°n pendientes.

### Ejemplo de Issue

| Issue | Estado | Etiquetas | Asignado a |
|-------|--------|-----------|------------|
| `#12: Jugador atraviesa paredes` | ‚ö† Abierto | `bug`, `high-priority` | Esther |
| `#15: A√±adir sonidos al recoger power-ups` | ‚úÖ Cerrado | `feature`, `audio` | Hugo |
| `#18: Mejora IA enemigos` | ‚è≥ En progreso | `enhancement`, `AI` | Alex |
| `#21: Pantalla de Game Over falta bot√≥n reiniciar` | ‚ö† Abierto | `bug`, `UI` | Fernando |

Al utilizar **GitHub Issues**, conseguimos centralizar la gesti√≥n de bugs y tareas en la misma plataforma que usamos para el c√≥digo, simplificando la administraci√≥n del proyecto y asegurando trazabilidad completa de los cambios implementados.

---

## Conclusiones ‚úÖ

Gracias a GitHub Flow y GitHub Issues, nuestro equipo mantiene main siempre estable y funcional, facilita la colaboraci√≥n, asegura la revisi√≥n de cada cambio y permite asociar tareas y bugs directamente a commits y Pull Requests. Esto garantiza un desarrollo m√°s ordenado, controlado y transparente, ideal para proyectos colaborativos como Escape del Laberinto.

---

## Autores ‚úçÔ∏è

- **Esther Peral Soler**
- **Hugo Redondo Vald√©s**
- **Alejandro Montoya Aracil**
- **Juan Fernando Ganim Iborra**
